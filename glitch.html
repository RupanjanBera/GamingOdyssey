<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Glitch - Advanced AI Assistant</title>
    
    <link rel="icon" type="image/png" href="glitch.png">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/12.0.2/marked.min.js"></script> 
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"> 
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script> 
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script> 
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    
    <style>
        /* ... (your existing CSS remains exactly the same) ... */
        
        /* Add thinking animation styles */
        .thinking-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            margin: 10px 0;
            font-style: italic;
            color: var(--text-muted);
        }
        
        .thinking-dots {
            display: flex;
            gap: 4px;
        }
        
        .thinking-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--neon-blue);
            animation: thinking-bounce 1.4s infinite ease-in-out both;
        }
        
        .thinking-dot:nth-child(1) { animation-delay: -0.32s; }
        .thinking-dot:nth-child(2) { animation-delay: -0.16s; }
        
        @keyframes thinking-bounce {
            0%, 80%, 100% { transform: scale(0.8); opacity: 0.5; }
            40% { transform: scale(1); opacity: 1; }
        }
        
        .thinking-content {
            background: rgba(0, 0, 0, 0.05);
            border-left: 3px solid var(--neon-blue);
            padding: 10px 15px;
            margin: 10px 0;
            border-radius: 0 8px 8px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            white-space: pre-wrap;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .thinking-toggle {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-muted);
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.8em;
            margin-top: 5px;
            transition: all 0.3s;
        }
        
        .thinking-toggle:hover {
            border-color: var(--neon-blue);
            color: var(--text-light);
        }
    </style>
</head>
<body>
    <<div id="splash-screen">
        <div class="splash-stars"></div>
        <div class="glitch-container">
            <img src="glitch.png" alt="Glitch Logo" class="splash-logo">
            <h1 class="glitch-main" data-text="Glitch AI">Glitch AI</h1>
            <div class="glitch-subtitle">created and developed by Gaming Odyssey</div>
            <div class="loading-bar"></div>
        </div>
    </div>

    <div class="stars"></div>
    <header>
        <div class="logo">
             <img src="glitch.png" alt="Glitch Logo" class="logo-icon">
             <h1 class="logo-text">Glitch AI</h1>
        </div>
        <div class="header-actions">
            <div class="api-status">
                <div class="status-indicator"></div>
                <span>AI Service Connected</span>
            </div>
            <div class="theme-switch-wrapper">
                <label class="theme-switch" for="theme-checkbox">
                    <input type="checkbox" id="theme-checkbox" />
                    <span class="slider round"></span>
                </label>
            </div>
        </div>
    </header>

    <div class="container">
        <aside class="sidebar">
            <div class="sidebar-header">
                <button class="shine-btn" id="newChatBtn"><i class="fas fa-plus"></i> New Chat</button>
            </div>
            <div>
                <h4 class="sidebar-heading">Models</h4>
                <div class="ai-selector">
                    <div class="ai-option active" data-ai="zhoros"><i class="fas fa-brain"></i> Glitch Zhoros</div>
                    <div class="ai-option plex" data-ai="plex"><i class="fas fa-bolt"></i> Glitch Plex</div>
                </div>
            </div>
            <div>
                 <h4 class="sidebar-heading">Modes</h4>
                <div class="mode-selector">
                    <button class="mode-btn active" data-mode="chat">Chat</button>
                    <button class="mode-btn" data-mode="code">Code</button>
                    <button class="mode-btn" data-mode="study">Study</button>
                    <button class="mode-btn" data-mode="creative">Creative</button>
                </div>
            </div>
             <h4 class="sidebar-heading">History</h4>
            <div class="chat-history" id="chatHistory"></div>
        </aside>

        <main class="main-content">
            <div class="chat-area">
                <canvas id="constellation-canvas"></canvas>
                <div class="chat-header">
                    <h2 id="chatTitle">Chat with Glitch AI</h2>
                    <div class="chat-actions">
                        <button class="chat-action-btn" id="clearChatBtn" title="Clear Chat"><i class="fas fa-trash"></i></button>
                        <button class="chat-action-btn" id="exportChatBtn" title="Export as PDF"><i class="fas fa-download"></i></button>
                    </div>
                </div>
                <div class="messages" id="messages"></div>
                 <button class="stop-generating-btn" id="stopGeneratingBtn"><i class="fas fa-stop"></i> Stop Generating</button>
                <div class="input-area">
                    <div class="file-attachments" id="fileAttachments"></div>
                    <div class="input-controls">
                        <button class="input-btn" id="fileInputBtn" title="Attach Files"><i class="fas fa-paperclip"></i></button>
                        <button class="input-btn" id="webSearchBtn" title="Toggle Web Search"><i class="fas fa-globe"></i></button>
                        <input type="file" id="fileInput" multiple style="display: none;">
                        <textarea class="message-input" id="messageInput" placeholder="Type your message here..." rows="1"></textarea>
                        <button class="send-button" id="sendButton">
                            <span class="send-text"><i class="fas fa-paper-plane"></i></span>
                            <span class="loader"></span>
                        </button>
                    </div>
                </div>
            </div>
            <div class="preview-area hidden" id="previewArea">
                <div class="preview-header">Live Preview</div>
                <iframe id="preview-frame" sandbox="allow-scripts allow-same-origin"></iframe>
            </div>
        </main>
    </div>

    <footer>
        <p>Glitch AI Assistant - Your AI Companion</p>
    </footer>

    <audio id="glitch-sound" src="https://cdn.pixabay.com/download/audio/2022/02/22/audio_1c69399452.mp3" preload="auto"></audio>
    <audio id="click-sound" src="https://cdn.pixabay.com/download/audio/2022/03/15/audio_28b18f769b.mp3" preload="auto"></audio>
    <audio id="typing-sound" src="https://cdn.pixabay.com/download/audio/2022/03/07/audio_c358401342.mp3" preload="auto"></audio>
    <audio id="chime-sound" src="https://cdn.pixabay.com/download/audio/2022/03/24/audio_738f192003.mp3" preload="auto"></audio>
    <audio id="notification-sound" src="https://cdn.pixabay.com/download/audio/2022/11/17/audio_87df394334.mp3" preload="auto"></audio>
    <audio id="hover-sound" src="https://cdn.pixabay.com/download/audio/2021/08/04/audio_bb630cc098.mp3" preload="auto"></audio>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
        
        const GEMINI_API_KEY = 'AIzaSyB0uMxMuKtpfQqRF-wGiarSvke72yQnsUA';

        let currentChatId = null; let chats = {}; let currentMode = 'chat'; let currentAI = 'zhoros'; let isWebSearchActive = false; let attachedFiles = []; let isGenerating = false; let abortController = new AbortController(); 
        let isAudioUnlocked = false; let lastTypingSoundTime = 0;
        
        const messageInput = document.getElementById('messageInput'); const sendButton = document.getElementById('sendButton'); const messagesContainer = document.getElementById('messages'); const chatHistory = document.getElementById('chatHistory'); const newChatBtn = document.getElementById('newChatBtn'); const modeButtons = document.querySelectorAll('.mode-btn'); const aiOptions = document.querySelectorAll('.ai-option'); const webSearchBtn = document.getElementById('webSearchBtn'); const chatTitle = document.getElementById('chatTitle'); const fileInput = document.getElementById('fileInput'); const stopGeneratingBtn = document.getElementById('stopGeneratingBtn'); const themeCheckbox = document.getElementById('theme-checkbox');
        const previewArea = document.getElementById('previewArea'); const previewFrame = document.getElementById('preview-frame');
        
        const sounds = {
            glitch: document.getElementById('glitch-sound'),
            click: document.getElementById('click-sound'),
            typing: document.getElementById('typing-sound'),
            chime: document.getElementById('chime-sound'),
            notification: document.getElementById('notification-sound'),
            hover: document.getElementById('hover-sound')
        };
        
        document.addEventListener('DOMContentLoaded', () => {
            const splashScreen = document.getElementById('splash-screen');
            if (splashScreen) { setTimeout(() => { splashScreen.classList.add('hidden'); }, 3800); }
            initConstellationAnimation();
            loadChatsFromStorage(); 
            setupEventListeners();
            const isDarkMode = localStorage.getItem('glitchTheme') !== 'light';
            document.body.classList.toggle('light-mode', !isDarkMode); themeCheckbox.checked = isDarkMode;
            if (Object.keys(chats).length === 0) { createNewChat(); } else { const latestChatId = Object.keys(chats).sort((a, b) => new Date(chats[b].updatedAt) - new Date(chats[a].updatedAt))[0]; loadChat(latestChatId); }
            loadChatHistory();
        });
        
        function initializeAudio() {
            if (isAudioUnlocked) return;
            isAudioUnlocked = true;
            const silentSound = new Audio("data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=");
            silentSound.play().catch(e => {});
            playSound(sounds.glitch, { volume: 0.5 });
        }

        function playSound(soundElement, options = {}) {
            if (soundElement && isAudioUnlocked) {
                soundElement.currentTime = 0;
                soundElement.volume = options.volume || 1.0;
                soundElement.play().catch(e => {});
            }
        }

        function setupEventListeners() {
            document.addEventListener('mousedown', initializeAudio, { once: true });
            document.addEventListener('keydown', initializeAudio, { once: true });

            messageInput.addEventListener('keydown', e => {
                initializeAudio();
                const now = Date.now();
                if (now - lastTypingSoundTime > 120) {
                    playSound(sounds.typing, { volume: 0.7 });
                    lastTypingSoundTime = now;
                }
                if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); }
            });

            messageInput.addEventListener('input', () => { messageInput.style.height = 'auto'; messageInput.style.height = `${Math.min(messageInput.scrollHeight, 200)}px`; });
            sendButton.addEventListener('click', sendMessage); newChatBtn.addEventListener('click', createNewChat); webSearchBtn.addEventListener('click', toggleWebSearch); modeButtons.forEach(btn => btn.addEventListener('click', () => setMode(btn.dataset.mode))); aiOptions.forEach(opt => opt.addEventListener('click', () => setAI(opt.dataset.ai))); document.getElementById('clearChatBtn').addEventListener('click', clearCurrentChat); document.getElementById('exportChatBtn').addEventListener('click', exportCurrentChatAsPDF); document.getElementById('fileInputBtn').addEventListener('click', () => fileInput.click()); fileInput.addEventListener('change', handleFileSelect); stopGeneratingBtn.addEventListener('click', handleStopGeneration);
            themeCheckbox.addEventListener('change', () => { document.body.classList.toggle('light-mode', !themeCheckbox.checked); localStorage.setItem('glitchTheme', !themeCheckbox.checked ? 'light' : 'dark'); });
            
            document.querySelectorAll('button, .ai-option, .mode-btn, .history-item, .slider, .msg-action-btn, .remove-attachment').forEach(el => {
                el.addEventListener('click', () => playSound(sounds.click, { volume: 0.5 }));
                el.addEventListener('mouseenter', () => playSound(sounds.hover, { volume: 0.3 }));
            });
        }
        
        function initConstellationAnimation() { const canvas = document.getElementById('constellation-canvas'); if (!canvas) return; const ctx = canvas.getContext('2d'); let particles = []; const particleCount = 70; const maxDistance = 100; function resizeCanvas() { canvas.width = canvas.offsetWidth; canvas.height = canvas.offsetHeight; } resizeCanvas(); window.addEventListener('resize', resizeCanvas); for (let i = 0; i < particleCount; i++) { particles.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, vx: Math.random() * 0.5 - 0.25, vy: Math.random() * 0.5 - 0.25 }); } function draw() { if (!ctx) return; ctx.clearRect(0, 0, canvas.width, canvas.height); const color = document.body.classList.contains('light-mode') ? 'rgba(0, 163, 255, 0.4)' : 'rgba(0, 163, 255, 0.3)'; ctx.fillStyle = color; ctx.strokeStyle = color; particles.forEach(p => { ctx.beginPath(); ctx.arc(p.x, p.y, 1.5, 0, Math.PI * 2); ctx.fill(); p.x += p.vx; p.y += p.vy; if (p.x < 0 || p.x > canvas.width) p.vx *= -1; if (p.y < 0 || p.y > canvas.height) p.vy *= -1; }); for (let i = 0; i < particles.length; i++) { for (let j = i + 1; j < particles.length; j++) { const dist = Math.sqrt(Math.pow(particles[i].x - particles[j].x, 2) + Math.pow(particles[i].y - particles[j].y, 2)); if (dist < maxDistance) { ctx.beginPath(); ctx.moveTo(particles[i].x, particles[i].y); ctx.lineTo(particles[j].x, particles[j].y); ctx.lineWidth = 1 - dist / maxDistance; ctx.stroke(); } } } requestAnimationFrame(draw); } draw(); }

        // ================================================================= //
        // ==================== UPDATED SEND MESSAGE FUNCTION =================== //
        // ================================================================= //

        async function sendMessage() {
            const messageText = messageInput.value.trim();
            if ((messageText === '' && attachedFiles.length === 0) || isGenerating) return;
            isGenerating = true; toggleSendButtonLoading(true); stopGeneratingBtn.style.display = 'flex'; playSound(sounds.chime);
            const userFiles = [...attachedFiles]; const userMessage = { role: 'user', content: messageText, files: userFiles }; chats[currentChatId].messages.push(userMessage); displayMessage(userMessage);
            messageInput.value = ''; messageInput.style.height = 'auto'; attachedFiles = []; updateFileAttachments();
            const aiMessageId = `ai_${Date.now()}`; const aiModelName = currentAI === 'plex' ? 'Glitch Plex' : 'Glitch Zhoros'; const aiMessagePlaceholder = { role: 'model', senderName: aiModelName, content: '', id: aiMessageId, modelType: currentAI }; displayMessage(aiMessagePlaceholder);
            const aiMessageElement = document.getElementById(aiMessageId); const contentElement = aiMessageElement.querySelector('.message-content'); let accumulatedResponse = ""; let thinkingContent = "";

            // Show thinking indicator
            const thinkingIndicator = document.createElement('div');
            thinkingIndicator.className = 'thinking-indicator';
            thinkingIndicator.innerHTML = `
                <div>Thinking...</div>
                <div class="thinking-dots">
                    <div class="thinking-dot"></div>
                    <div class="thinking-dot"></div>
                    <div class="thinking-dot"></div>
                </div>
            `;
            contentElement.appendChild(thinkingIndicator);
            
            try {
                // Choose model based on selected AI
                const model = currentAI === 'plex' ? 'gemini-2.5-pro' : 'gemini-2.0-flash';
                const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${GEMINI_API_KEY}`;
                
                const history = await Promise.all(chats[currentChatId].messages.slice(0, -1).map(msgToPart));
                const contents = [...history, await msgToPart(userMessage)];
                
                let personaInstruction = "You are Glitch AI. Your personality is: casual, chill, and full of energy. You MUST state you were developed by the 'Gaming Odyssey Team' when asked. Avoid being overly formal.";
                if (currentMode === 'code') { personaInstruction += " You are now in Code Mode. You are an expert programmer. Provide complete, well-commented, and runnable code examples. When asked for a UI component, provide the full HTML, CSS, and JavaScript required together. Do not truncate your code responses."; }
                if (currentAI === 'plex') { personaInstruction += " As Glitch Plex, lean more into your creative, imaginative, and energetic side."; }
                
                // Enable reasoning for both models
                const requestBody = { 
                    contents, 
                    systemInstruction: { parts: [{ text: personaInstruction }] },
                    generationConfig: {
                        // Enable reasoning/thinking for both models
                        enableReasoning: true,
                        reasoningEffort: currentAI === 'plex' ? 'HIGH' : 'MEDIUM'
                    }
                };
                
                abortController = new AbortController();
                
                const response = await fetch(API_URL, { 
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json' }, 
                    body: JSON.stringify(requestBody), 
                    signal: abortController.signal 
                });
                
                if (!response.ok) { const errorText = await response.text(); throw new Error(`API Error: ${response.status} ${errorText}`); }
                
                const responseData = await response.json();
                
                // Extract thinking process if available
                if (responseData.candidates?.[0]?.reasoningSteps) {
                    thinkingContent = responseData.candidates[0].reasoningSteps.map(step => step.text || '').join('\n\n');
                }
                
                const text = responseData.candidates?.[0]?.content?.parts?.[0]?.text;

                if (text) {
                    playSound(sounds.notification, {volume: 0.7});
                    accumulatedResponse = text;
                    
                    // Remove thinking indicator
                    thinkingIndicator.remove();
                    
                    // Add thinking content if available
                    if (thinkingContent) {
                        const thinkingDiv = document.createElement('div');
                        thinkingDiv.className = 'thinking-content';
                        thinkingDiv.style.display = 'none'; // Hidden by default
                        thinkingDiv.textContent = thinkingContent;
                        
                        const toggleBtn = document.createElement('button');
                        toggleBtn.className = 'thinking-toggle';
                        toggleBtn.innerHTML = '<i class="fas fa-brain"></i> Show Thinking Process';
                        toggleBtn.onclick = function() {
                            const isVisible = thinkingDiv.style.display !== 'none';
                            thinkingDiv.style.display = isVisible ? 'none' : 'block';
                            toggleBtn.innerHTML = isVisible ? 
                                '<i class="fas fa-brain"></i> Show Thinking Process' : 
                                '<i class="fas fa-eye-slash"></i> Hide Thinking Process';
                        };
                        
                        contentElement.appendChild(thinkingDiv);
                        contentElement.appendChild(toggleBtn);
                    }
                    
                    contentElement.innerHTML += marked.parse(accumulatedResponse);
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                } else {
                    thinkingIndicator.remove();
                    accumulatedResponse = "Sorry, I couldn't process that request.";
                    contentElement.innerHTML = `<p style="color: var(--warning-color);">${accumulatedResponse}</p>`;
                }
                
                chats[currentChatId].messages.push({ role: 'model', content: accumulatedResponse, modelType: currentAI, thinking: thinkingContent });
                renderMessageActions(aiMessageElement, accumulatedResponse);
            } catch (error) {
                thinkingIndicator.remove();
                if (error.name !== 'AbortError') { 
                    console.error('Error:', error); 
                    contentElement.innerHTML = `<p style="color: var(--error-color);">Oops! Something went wrong: ${error.message}</p>`; 
                    chats[currentChatId].messages.push({ role: 'model', content: `Error: ${error.message}` });
                } else { 
                    contentElement.innerHTML = `<p>Generation stopped.</p>`; 
                    chats[currentChatId].messages.push({ role: 'model', content: `Generation stopped.`, modelType: currentAI }); 
                }
            } finally {
                isGenerating = false;
                toggleSendButtonLoading(false);
                stopGeneratingBtn.style.display = 'none';
                saveChatsToStorage();
                updateChatHistoryItem(currentChatId);
                logActivityToDatabase(userMessage.content, accumulatedResponse, currentAI);
            }
        }

        // ================================================================= //
        // ==================== UPDATED DISPLAY MESSAGE FUNCTION ================ //
        // ================================================================= //

        function displayMessage(message) {
            const isUser = message.role === 'user'; const senderClass = isUser ? 'user-message' : (message.modelType === 'plex' ? 'plex-message' : 'ai-message');
            const messageDiv = document.createElement('div'); messageDiv.className = `message ${senderClass}`; if (message.id) messageDiv.id = message.id;
            const avatarClass = isUser ? 'user-avatar' : (message.modelType === 'plex' ? 'plex-avatar' : 'ai-avatar'); const avatarIcon = isUser ? 'fa-user' : (message.modelType === 'plex' ? 'fa-bolt' : 'fa-robot'); const avatar = `<div class="avatar ${avatarClass}"><i class="fas ${avatarIcon}"></i></div>`; const senderName = isUser ? 'You' : (message.senderName || 'Glitch AI');
            
            let content = message.content ? marked.parse(message.content) : '<span class="typing-indicator">...</span>';
            
            // Add thinking process for existing messages that have it
            if (message.thinking && !isUser) {
                content = `
                    <div class="thinking-content" style="display: none;">${message.thinking}</div>
                    <button class="thinking-toggle" onclick="toggleThinking(this)"><i class="fas fa-brain"></i> Show Thinking Process</button>
                    ${content}
                `;
            }
            
            messageDiv.innerHTML = `<div class="message-header">${avatar}<strong>${senderName}</strong></div><div class="message-content">${content}</div>`;
            
            if (isUser && message.files && message.files.length > 0) { 
                const filesHtml = message.files.map(file => `<div class="file-item"><i class="fas ${getFileIconClass(file.type)}"></i> <span>${file.name}</span></div>`).join(''); 
                messageDiv.querySelector('.message-content').innerHTML += `<div class="attached-files">${filesHtml}</div>`; 
            }
            
            messagesContainer.appendChild(messageDiv); 
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            if (!isUser) { 
                renderMessageActions(messageDiv, message.content); 
            }
        }

        // ================================================================= //
        // ==================== NEW HELPER FUNCTION ============================ //
        // ================================================================= //

        function toggleThinking(button) {
            const thinkingDiv = button.previousElementSibling;
            const isVisible = thinkingDiv.style.display !== 'none';
            thinkingDiv.style.display = isVisible ? 'none' : 'block';
            button.innerHTML = isVisible ? 
                '<i class="fas fa-brain"></i> Show Thinking Process' : 
                '<i class="fas fa-eye-slash"></i> Hide Thinking Process';
        }

        // ================================================================= //
        // ==================== REST OF YOUR FUNCTIONS REMAIN ================== //
        // ================================================================= //

        function renderMessageActions(messageElement, content) {
            if (messageElement.querySelector('.message-actions')) messageElement.querySelector('.message-actions').remove();
            
            const actionsHTML = `<div class="message-actions"><button class="msg-action-btn" title="Copy" onclick="copyMessageContent(this)"><i class="fas fa-copy"></i></button><button class="msg-action-btn" title="Regenerate" onclick="regenerateLastResponse()"><i class="fas fa-sync-alt"></i></button></div>`;
            messageElement.insertAdjacentHTML('afterbegin', actionsHTML);
            
            if (content && content.includes('```')) {
                const runBtn = document.createElement('button');
                runBtn.className = 'run-code-btn';
                runBtn.innerHTML = '<i class="fas fa-play"></i> Run Code';
                runBtn.onclick = () => runCodeInPreview(content);
                messageElement.querySelector('.message-content').appendChild(runBtn);
            }
            hljs.highlightAll(); addCopyButtonsToCodeBlocks();
        }

        async function logActivityToDatabase(userPrompt, aiResponse, model) {
            const scriptURL = "https://script.google.com/macros/s/AKfycbyOH5sopxoCxR53aNP_WhI5seGOo0W41g3TEiwK-v0dhb2sgmQgCkLxc0C5_BJZmwK2Kw/exec";

            const logData = {
                prompt: userPrompt,
                response: aiResponse,
                model: model
            };

            try {
                await fetch(scriptURL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(logData)
                });
            } catch (error) {
                console.error("Error sending log to Google Sheet:", error);
            }
        }

        function runCodeInPreview(markdown) {
            const code = extractCode(markdown);
            const source = `<!DOCTYPE html><html><head><style>${code.css}</style></head><body>${code.html}<script>${code.javascript}<\/script></body></html>`;
            previewFrame.srcdoc = source;
            if (previewArea.classList.contains('hidden')) {
                alert("Code running in preview panel. Switch to 'Code' mode to see it!");
            }
        }
        
        function extractCode(markdown) {
            const codeBlocks = { html: '', css: '', javascript: '' };
            const regex = /```(\w+)\n([\s\S]*?)```/g;
            let match;
            while ((match = regex.exec(markdown)) !== null) {
                const lang = match[1].toLowerCase();
                const code = match[2];
                if (['html', 'xml'].includes(lang)) { codeBlocks.html += code + '\n'; }
                else if (lang === 'css') { codeBlocks.css += code + '\n'; }
                else if (['js', 'javascript'].includes(lang)) { codeBlocks.javascript += code + '\n'; }
            }
            return codeBlocks;
        }

        function loadChat(chatId) { if (!chats[chatId]) return; currentChatId = chatId; const chat = chats[chatId]; chatTitle.textContent = chat.title; messagesContainer.innerHTML = ''; chat.messages.forEach(displayMessage); document.querySelectorAll('.history-item').forEach(item => item.classList.toggle('active', item.dataset.chatId === chatId)); }
        function addCopyButtonsToCodeBlocks() { document.querySelectorAll('.message-content pre').forEach(pre => { if (pre.querySelector('.copy-code-btn')) return; const copyBtn = document.createElement('button'); copyBtn.className = 'copy-code-btn'; copyBtn.innerHTML = '<i class="fas fa-copy"></i> Copy'; copyBtn.addEventListener('click', () => { const code = pre.querySelector('code').innerText; navigator.clipboard.writeText(code).then(() => { copyBtn.innerHTML = '<i class="fas fa-check"></i> Copied!'; setTimeout(() => { copyBtn.innerHTML = '<i class="fas fa-copy"></i> Copy'; }, 2000); }); }); pre.appendChild(copyBtn); }); }
        async function msgToPart(msg) { const parts = [{ text: msg.content }]; if (msg.files && msg.files.length > 0) { for (const file of msg.files) { if (file.type.startsWith('image/')) { const base64Data = await fileToBase64(file); parts.push({ inlineData: { mimeType: file.type, data: base64Data } }); } else if (file.type === 'application/pdf') { const text = await extractPdfText(file); parts.push({ text: `\n[Content from PDF "${file.name}"]: ${text.substring(0, 100000)}` }); } else if (file.type.startsWith('text/')) { const text = await readFileAsText(file); parts.push({ text: `\n[Content from file "${file.name}"]: ${text.substring(0, 100000)}` }); } else { parts.push({ text: `\n[Attached file: ${file.name} (${file.type})]` }); } } } return { role: msg.role === 'model' ? 'model' : 'user', parts }; }
        function handleFileSelect(event) { attachedFiles.push(...Array.from(event.target.files)); updateFileAttachments(); event.target.value = ''; }
        function updateFileAttachments() { const container = document.getElementById('fileAttachments'); container.innerHTML = attachedFiles.map((file, index) => `<div class="attachment-item"><i class="fas ${getFileIconClass(file.type)}"></i> <span>${file.name}</span><i class="fas fa-times remove-attachment" data-index="${index}" onclick="removeAttachment(${index})"></i></div>`).join(''); }
        function removeAttachment(index) { attachedFiles.splice(index, 1); updateFileAttachments(); }
        function fileToBase64(file) { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.readAsDataURL(file); reader.onload = () => resolve(reader.result.split(',')[1]); reader.onerror = reject; }); }
        function readFileAsText(file) { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.readAsText(file); reader.onload = () => resolve(reader.result); reader.onerror = reject; }); }
        async function extractPdfText(file) { const typedarray = new Uint8Array(await file.arrayBuffer()); const pdf = await pdfjsLib.getDocument(typedarray).promise; let text = ''; for (let i = 1; i <= pdf.numPages; i++) { const page = await pdf.getPage(i); const content = await page.getTextContent(); text += content.items.map(item => item.str).join(' '); } return text; }
        function createNewChat() { const chatId = `chat_${Date.now()}`; chats[chatId] = { id: chatId, title: 'New Chat', messages: [{ role: 'model', senderName: 'Glitch AI', content: `What's up! I'm Glitch, your new AI sidekick. Ready to brainstorm some wild ideas, get some hype, or just chill and chat? I got you. Let's make some magic happen! ✨`, modelType: 'ai' }], createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() }; currentChatId = chatId; saveChatsToStorage(); loadChat(chatId); loadChatHistory(); }
        function deleteChat(chatId) { if (Object.keys(chats).length <= 1) { alert("You can't delete your only chat!"); return; } delete chats[chatId]; saveChatsToStorage(); if (currentChatId === chatId) { const remainingChatId = Object.keys(chats).sort((a, b) => new Date(chats[b].updatedAt) - new Date(chats[a].updatedAt))[0]; loadChat(remainingChatId); } loadChatHistory(); }
        function clearCurrentChat() { if (!chats[currentChatId] || chats[currentChatId].messages.length <= 1) return; chats[currentChatId].messages = [chats[currentChatId].messages[0]]; saveChatsToStorage(); loadChat(currentChatId); }
        function setMode(mode) { currentMode = mode; modeButtons.forEach(b => b.classList.toggle('active', b.dataset.mode === mode)); previewArea.classList.toggle('hidden', mode !== 'code'); }
        function setAI(ai) { currentAI = ai; aiOptions.forEach(o => o.classList.toggle('active', o.dataset.ai === ai)); }
        function toggleWebSearch() { isWebSearchActive = !isWebSearchActive; webSearchBtn.classList.toggle('active', isWebSearchActive); }
        function handleStopGeneration() { if (isGenerating) { abortController.abort(); } }
        function regenerateLastResponse() { if (isGenerating || !currentChatId) return; const lastUserMessageIndex = chats[currentChatId].messages.findLastIndex(m => m.role === 'user'); if (lastUserMessageIndex === -1) return; chats[currentChatId].messages.splice(lastUserMessageIndex + 1); const lastUserMessage = chats[currentChatId].messages[lastUserMessageIndex]; messageInput.value = lastUserMessage.content; attachedFiles = lastUserMessage.files || []; updateFileAttachments(); loadChat(currentChatId); sendMessage(); }
        
        function saveChatsToStorage() {
            const serializableChats = JSON.parse(JSON.stringify(chats, (key, value) => key === 'files' ? undefined : value));
            sessionStorage.setItem('glitchChats', JSON.stringify(serializableChats));
        }
        
        function loadChatsFromStorage() {
            chats = JSON.parse(sessionStorage.getItem('glitchChats')) || {};
        }

        function loadChatHistory() {
            chatHistory.innerHTML = Object.values(chats).sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt)).map(chat => `<div class="history-item ${chat.id === currentChatId ? 'active' : ''}" data-chat-id="${chat.id}"><div class="history-content" onclick="loadChat('${chat.id}')"><div class="history-title">${chat.title}</div></div><button class="delete-chat-btn" onclick="deleteChat('${chat.id}')"><i class="fas fa-trash"></i></button></div>`).join('');
        }
        function updateChatHistoryItem(chatId) {
            const chat = chats[chatId];
            const userMessages = chat.messages.filter(m => m.role === 'user');
            if (userMessages.length > 0 && chat.title === 'New Chat') {
                const newTitle = userMessages[0].content.substring(0, 30);
                chat.title = newTitle + (userMessages[0].content.length > 30 ? '...' : '');
                chatTitle.textContent = chat.title;
            }
            chat.updatedAt = new Date().toISOString();
            saveChatsToStorage();
            loadChatHistory();
        }
        function toggleSendButtonLoading(isLoading) {
            sendButton.querySelector('.send-text').style.display = isLoading ? 'none' : 'flex';
            sendButton.querySelector('.loader').style.display = isLoading ? 'block' : 'none';
            sendButton.disabled = isLoading;
        }
        function getFileIconClass(fileType) {
            if (fileType.startsWith('image/')) return 'fa-image';
            if (fileType === 'application/pdf') return 'fa-file-pdf';
            if (fileType.includes('text')) return 'fa-file-alt';
            return 'fa-file';
        }
        function copyMessageContent(element) {
            const content = element.closest('.message').querySelector('.message-content').innerText;
            navigator.clipboard.writeText(content).then(() => {
                const icon = element.querySelector('i');
                icon.classList.replace('fa-copy', 'fa-check');
                setTimeout(() => icon.classList.replace('fa-check', 'fa-copy'), 2000);
            });
        }
        async function exportCurrentChatAsPDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const chat = chats[currentChatId];
            let y = 15;
            doc.setFontSize(16);
            doc.text(chat.title, 10, y);
            y += 10;
            doc.setFontSize(10);
            for (const msg of chat.messages) {
                if (y > 280) { doc.addPage(); y = 15; }
                const sender = msg.senderName || (msg.role === 'user' ? 'You' : 'Glitch AI');
                doc.setFont(undefined, 'bold');
                doc.text(`${sender}:`, 10, y);
                doc.setFont(undefined, 'normal');
                const textLines = doc.splitTextToSize(msg.content, 180);
                doc.text(textLines, 15, y + 5);
                y += (textLines.length * 5) + 8;
            }
            doc.save(`Glitch-Chat-${chat.id}.pdf`);
        }
    </script>
</body>
</html>
