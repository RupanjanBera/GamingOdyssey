<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>J.A.R.V.I.S. AI Interface - Advanced HUD</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <style>
        /* --- Basic Setup & Theme --- */
        :root {
            --neon-blue: #00d9ff;
            --dark-blue: #0a192f;
            --glow-color: rgba(0, 217, 255, 0.75);
            --bg-color: #000000; /* True black for transparent effect */
            --neon-red: #ff004c;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: var(--bg-color);
            color: var(--neon-blue);
            font-family: 'Orbitron', sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
        }

        /* --- Vision HUD & Background Replacement --- */
        .jarvis-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            /* Backgrounds removed for transparent HUD look */
        }
        
        /* --- Start Overlay --- */
        #start-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 5, 10, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 100;
            cursor: pointer;
            transition: opacity 0.5s ease;
        }
        
        #start-overlay h1 {
            font-size: 3rem;
            text-shadow: 0 0 15px var(--glow-color);
            margin-bottom: 20px;
        }

        #start-overlay p {
            font-size: 1.2rem;
            animation: pulse-text 2s infinite;
        }
        
        @keyframes pulse-text {
            0% { opacity: 1; }
            50% { opacity: 0.6; }
            100% { opacity: 1; }
        }
        
        /* --- Face Auth Overlay (Retained original structure for initialization) --- */
        #face-auth-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: none; /* Start hidden */
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 200;
            transition: opacity 0.5s ease;
        }

        #video-wrapper {
            position: relative;
            width: 480px;
            height: 360px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
            overflow: hidden;
            border-radius: 10px;
            border: 2px solid var(--neon-blue);
            box-shadow: 0 0 20px var(--glow-color);
        }

        #webcam-feed {
            width: 100%;
            height: 100%;
            transform: scaleX(-1); /* Mirror effect */
            object-fit: cover;
        }

        #scan-line {
            position: absolute;
            width: 100%;
            height: 4px;
            background: linear-gradient(to right, transparent, var(--neon-blue), transparent);
            box-shadow: 0 0 10px var(--glow-color);
            top: 0;
            left: 0;
            opacity: 0;
        }

        @keyframes scan-vertical {
            0% { top: 0; opacity: 1; }
            100% { top: 100%; opacity: 1; }
        }

        #auth-status {
            font-size: 1.2rem;
            margin-top: 20px;
            text-shadow: 0 0 10px var(--glow-color);
            animation: pulse-text 2s infinite;
        }

        /* --- NEW: Vision/Object Detection Overlay (Primary Camera View) --- */
        #vision-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none; /* Start hidden */
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 200;
            transition: opacity 0.5s ease;
        }

        #vision-feed {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1); /* Mirror effect */
            object-fit: cover;
            z-index: 201;
            opacity: 0.8; /* Make it slightly transparent */
        }
        
        #vision-canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 202; /* Draw HUD over video */
        }

        #vision-status {
            position: absolute;
            bottom: 50px;
            font-size: 1.5rem;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            text-shadow: 0 0 10px var(--glow-color);
            z-index: 203;
            animation: pulse-text 2s infinite;
        }
        /* --- END NEW Vision Overlay --- */

        /* --- Central 3D Core & HUD Rings --- */
        #jarvis-core {
            position: absolute;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .hud-ring {
            position: absolute;
            border: 2px solid var(--neon-blue);
            border-radius: 50%;
            box-shadow: 0 0 15px var(--glow-color), inset 0 0 10px var(--glow-color);
            opacity: 0.7;
            pointer-events: none;
        }

        .ring-1 { width: 400px; height: 400px; }
        .ring-2 { width: 450px; height: 450px; border-style: dashed; }
        .ring-3 { width: 500px; height: 500px; }

        /* --- Chat Window --- */
        .chat-container {
            position: absolute;
            right: 20px;
            top: 20px;
            width: 350px;
            height: calc(100vh - 180px);
            background: rgba(10, 25, 47, 0.5);
            border: 1px solid var(--neon-blue);
            box-shadow: 0 0 10px var(--glow-color);
            backdrop-filter: blur(5px);
            z-index: 10;
            display: flex;
            flex-direction: column;
            border-radius: 10px;
        }
        
        #chat-box {
            flex-grow: 1;
            padding: 15px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        /* Custom scrollbar for chat */
        #chat-box::-webkit-scrollbar { width: 6px; }
        #chat-box::-webkit-scrollbar-track { background: transparent; }
        #chat-box::-webkit-scrollbar-thumb { background: var(--neon-blue); border-radius: 3px; }

        .chat-message {
            padding: 10px 15px;
            border-radius: 8px;
            max-width: 85%;
            word-wrap: break-word;
            line-height: 1.4;
        }

        .user-message {
            background: rgba(0, 217, 255, 0.1);
            border: 1px solid var(--neon-blue);
            align-self: flex-end;
            text-align: right;
            box-shadow: 0 0 8px rgba(0, 217, 255, 0.3);
        }
        
        .jarvis-message {
            background: rgba(10, 25, 47, 0.8);
            border: 1px solid var(--neon-blue);
            align-self: flex-start;
            box-shadow: 0 0 8px rgba(0, 217, 255, 0.3);
        }

        .jarvis-message.thinking, .jarvis-message.searching, .jarvis-message.scanning {
             font-style: italic;
             color: rgba(0, 217, 255, 0.6);
        }
        
        /* --- Input Area & Mic Button --- */
        .input-container {
            position: absolute;
            bottom: 30px;
            width: 50%;
            max-width: 600px;
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 10;
        }

        #user-input {
            flex-grow: 1;
            background: rgba(10, 25, 47, 0.7);
            border: 1px solid var(--neon-blue);
            border-radius: 5px;
            padding: 15px;
            color: var(--neon-blue);
            font-family: 'Orbitron', sans-serif;
            font-size: 16px;
            outline: none;
            box-shadow: 0 0 10px var(--glow-color);
            transition: box-shadow 0.3s ease;
        }
        
        #user-input:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #user-input:focus { box-shadow: 0 0 20px var(--glow-color); }

        #mic-btn {
            width: 60px;
            height: 60px;
            background: var(--dark-blue);
            border: 2px solid var(--neon-blue);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 0 15px var(--glow-color);
            transition: all 0.3s ease;
            animation: pulse 2s infinite;
        }
        
        #mic-btn.listening {
            background: var(--neon-blue);
            box-shadow: 0 0 25px var(--glow-color), 0 0 35px var(--glow-color);
            animation: none;
        }

        #mic-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            animation: none;
        }

        #mic-btn svg {
            width: 28px;
            height: 28px;
            fill: var(--neon-blue);
            transition: fill 0.3s ease;
        }
        
        #mic-btn.listening svg { fill: var(--bg-color); }

        @keyframes pulse {
            0% { box-shadow: 0 0 15px var(--glow-color); }
            50% { box-shadow: 0 0 25px var(--glow-color); }
            100% { box-shadow: 0 0 15px var(--glow-color); }
        }

        /* --- Waveform Visualization --- */
        #waveform-canvas {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 50px;
            z-index: 5;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #waveform-canvas.visible { opacity: 0.7; }

        /* --- Status Indicator --- */
        #status-indicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(10, 25, 47, 0.8);
            padding: 8px 15px;
            border-radius: 20px;
            border: 1px solid var(--neon-blue);
            box-shadow: 0 0 10px var(--glow-color);
            z-index: 20;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #00ff00;
            animation: pulse 2s infinite;
        }

        .status-dot.offline {
            background: #ff0000;
        }

        .status-dot.warning {
            background: #ffff00;
        }

        /* --- System Info Panel --- */
        #system-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(10, 25, 47, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid var(--neon-blue);
            box-shadow: 0 0 10px var(--glow-color);
            z-index: 20;
            max-width: 250px;
        }

        .system-item {
            margin: 5px 0;
            font-size: 0.9rem;
        }

        /* --- Microphone Permission Overlay --- */
        #mic-permission-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 5, 10, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 150;
            text-align: center;
            padding: 20px;
        }

        #mic-permission-overlay h2 {
            font-size: 2rem;
            margin-bottom: 20px;
            text-shadow: 0 0 15px var(--glow-color);
        }

        #mic-permission-overlay p {
            font-size: 1.1rem;
            margin-bottom: 30px;
            max-width: 500px;
        }

        #grant-mic-btn {
            background: var(--dark-blue);
            border: 2px solid var(--neon-blue);
            color: var(--neon-blue);
            padding: 15px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.1rem;
            transition: all 0.3s ease;
            box-shadow: 0 0 15px var(--glow-color);
        }

        #grant-mic-btn:hover {
            background: var(--neon-blue);
            color: var(--dark-blue);
            box-shadow: 0 0 25px var(--glow-color);
        }

        /* --- Clear Chat Button --- */
        #clear-chat-btn {
            position: absolute;
            bottom: 30px;
            right: 390px;
            background: var(--dark-blue);
            border: 1px solid var(--neon-blue);
            color: var(--neon-blue);
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            box-shadow: 0 0 10px var(--glow-color);
            z-index: 10;
        }
        
        #clear-chat-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            animation: none;
        }

        #clear-chat-btn:hover {
            background: var(--neon-blue);
            color: var(--dark-blue);
            box-shadow: 0 0 15px var(--glow-color);
        }

        /* --- Model Toggle Button --- */
        #model-toggle-btn {
            position: absolute;
            top: 70px;
            right: 390px;
            background: rgba(10, 25, 47, 0.8);
            padding: 8px 15px;
            border-radius: 20px;
            border: 1px solid var(--neon-blue);
            box-shadow: 0 0 10px var(--glow-color);
            z-index: 20;
            font-family: 'Orbitron', sans-serif;
            color: var(--neon-blue);
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        #model-toggle-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            animation: none;
        }

        #model-toggle-btn:hover {
            background: var(--neon-blue);
            color: var(--dark-blue);
            box-shadow: 0 0 15px var(--glow-color);
        }

        /* --- Media Player (Retained original styles) --- */
        #media-player-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 300px;
            background: rgba(10, 25, 47, 0.8);
            border: 1px solid var(--neon-blue);
            box-shadow: 0 0 10px var(--glow-color);
            backdrop-filter: blur(5px);
            z-index: 25;
            border-radius: 10px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            transition: opacity 0.5s ease, transform 0.5s ease;
            transform: translateY(200%);
        }

        #media-player-container.visible {
            transform: translateY(0);
        }

        #media-info {
            font-size: 0.9rem;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #player-wrapper {
            width: 100%;
            height: 150px;
            background: #000;
            border-radius: 5px;
            position: relative;
        }

        #youtube-player {
            width: 100%;
            height: 100%;
            opacity: 0.9;
        }

        #close-player-btn {
            position: absolute;
            top: -10px;
            right: -10px;
            width: 24px;
            height: 24px;
            background: var(--dark-blue);
            border: 1px solid var(--neon-blue);
            color: var(--neon-blue);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: sans-serif;
            font-weight: bold;
            box-shadow: 0 0 8px var(--glow-color);
        }

        #custom-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            padding-top: 5px;
        }

        #custom-controls button {
            background: rgba(10, 25, 47, 0.8);
            border: 1px solid var(--neon-blue);
            color: var(--neon-blue);
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            border-radius: 5px;
            padding: 5px 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 5px var(--glow-color);
            min-width: 60px;
        }

        #custom-controls button:hover {
            background: var(--neon-blue);
            color: var(--dark-blue);
            box-shadow: 0 0 10px var(--glow-color);
        }
        
        /* --- Self-Destruct Effect (Retained original styles) --- */
        #destruction-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 9999;
            display: none;
            opacity: 0;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            color: red;
            font-size: 1.5rem;
            text-shadow: 0 0 10px red;
        }

        #destruction-overlay.active {
            display: flex;
            animation: white-flash 0.2s ease-out;
        }

        .jarvis-container.shake {
            animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
            transform: translate3d(0, 0, 0);
        }
        
        #destruction-overlay .glitch-text {
            position: relative;
            font-size: 2rem;
            color: var(--neon-red);
            text-shadow: 0 0 10px var(--neon-red);
            animation: glitch-skew 1s infinite linear alternate-reverse;
        }
        
        #destruction-overlay .glitch-text::before,
        #destruction-overlay .glitch-text::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
        }
        
        @keyframes white-flash {
            0% { opacity: 0; background: #000; }
            50% { opacity: 1; background: #fff; }
            100% { opacity: 1; background: #000; }
        }

        @keyframes shake {
          10%, 90% { transform: translate3d(-1px, 0, 0); }
          20%, 80% { transform: translate3d(2px, 0, 0); }
          30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
          40%, 60% { transform: translate3d(4px, 0, 0); }
        }
        
    </style>
</head>
<body>
    <div id="start-overlay">
        <h1>J.A.R.V.I.S.</h1>
        <p>Click to Initialize</p>
    </div>

    <div id="face-auth-overlay" style="display: none;">
        <div id="video-wrapper">
            <video id="webcam-feed" autoplay playsinline muted></video>
            <div id="scan-line"></div>
        </div>
        <p id="auth-status">Initializing Biometric Scan...</p>
    </div>
    
    <div id="vision-overlay" style="display: none;">
        <video id="vision-feed" autoplay playsinline muted></video>
        <canvas id="vision-canvas"></canvas>
        <p id="vision-status">Scanning for Objects...</p>
    </div>
    <div id="destruction-overlay">
        <span class="glitch-text" data-text="...CONNECTION TERMINATED...">...CONNECTION TERMINATED...</span>
    </div>

    <div id="mic-permission-overlay" style="display: none;">
        <h2>Microphone Access Required</h2>
        <p>To use voice commands with J.A.R.V.I.S., please grant microphone access. This permission will be remembered and you won't be asked again.</p>
        <button id="grant-mic-btn">Grant Microphone Access</button>
    </div>

    <div class="jarvis-container">
        <canvas id="jarvis-core"></canvas>

        <div class="hud-ring ring-1"></div>
        <div class="hud-ring ring-2"></div>
        <div class="hud-ring ring-3"></div>

        <div id="status-indicator">
            <div class="status-dot" id="status-dot"></div>
            <span id="status-text">System Ready</span>
        </div>

        <button id="model-toggle-btn">Model: JARVIS Pro</button>

        <div id="system-info">
            <div class="system-item" id="current-time">Time: Loading...</div>
            <div class="system-item" id="current-date">Date: Loading...</div>
            <div class="system-item">Memory: <span id="memory-count">0</span> items</div>
            <div class="system-item">Conversation: <span id="chat-count">0</span> messages</div>
            <div class="system-item">Microphone: <span id="mic-status">Checking...</span></div>
        </div>

        <div class="chat-container">
            <div id="chat-box"></div>
        </div>

        <button id="clear-chat-btn">Clear Chat</button>

        <div id="media-player-container">
            <button id="close-player-btn">X</button>
            <div id="media-info">Now Playing...</div>
            <div id="player-wrapper">
                <div id="youtube-player"></div>
            </div>
            <div id="custom-controls">
                <button id="seek-backward-btn">« 10s</button>
                <button id="play-pause-btn">PLAY</button>
                <button id="seek-forward-btn">10s »</button>
            </div>
            </div>

        <canvas id="waveform-canvas"></canvas>

        <div class="input-container">
            <input type="text" id="user-input" placeholder="Type or press mic to talk...">
            <button id="mic-btn">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><path d="M192 0C139 0 96 43 96 96V256c0 53 43 96 96 96s96-43 96-96V96c0-53-43-96-96-96zM64 216c0-21.2 11.1-40.1 28.6-51.4l1.2-1.2c-12.3-17.7-19.8-38.6-19.8-61.4C74 42.6 126.6 0 192 0s118 42.6 118 102c0 22.8-7.5 43.7-19.8 61.4l1.2 1.2C308.9 175.9 320 194.8 320 216v40c0 13.3-10.7 24-24 24s-24-10.7-24-24V216c0-13.2-5.4-25.2-14.1-33.9C249.2 173.4 238.4 168 224 168c-14.4 0-25.2 5.4-33.9 14.1C181.4 190.8 176 202.8 176 216v40c0 13.3-10.7 24-24 24s-24-10.7-24-24V216zM192 480c35.3 0 64-28.7 64-64H128c0 35.3 28.7 64 64 64z"/></svg>
            </button>
        </div>
    </div>
    
    <audio id="intro-voice" preload="auto"></audio>
    <audio id="start-sound" preload="auto"></audio>
    <audio id="end-sound" preload="auto"></audio>
    <audio id="self-destruct-sound" src="https://gamingodyssey.in/boom.mp3" preload="auto"></audio>
    <audio id="scan-start-sound" src="https://assets.mixkit.co/sfx/preview/mixkit-futuristic-technology-scan-2407.mp3" preload="auto"></audio>
    <audio id="scan-complete-sound" src="https://assets.mixkit.co/sfx/preview/mixkit-tech-confirmation-992.mp3" preload="auto"></audio>

    <script type="module">
    // --- API Configuration ---
    const GEMINI_API_KEY = 'AIzaSyCpm_74JDyLRhL8ZZ2_wxl6HOZDHNT1zT8'; // YOUR PROVIDED KEY
    const GOOGLE_SEARCH_API_KEY = AIzaSyBm8SxGHDl9pkrDuZt_VgFQME9a3aRUeXY; 
    const SEARCH_ENGINE_ID = 'd13b9c982e19f4ccf';
    const GOOGLE_SEARCH_URL = `https://www.googleapis.com/customsearch/v1?key=${GOOGLE_SEARCH_API_KEY}&cx=${SEARCH_ENGINE_ID}`;
    
    // --- OLLAMA Configuration (Primary AI) ---
    const OLLAMA_MODEL_NAME = 'deepseek-r1:8b';
    const OLLAMA_API_URL = 'http://localhost:11434/api/generate'; 

    // --- Model Selection Logic ---
    const MODELS = {
        'JARVIS Pro': OLLAMA_MODEL_NAME, 
        'JARVIS Flash': OLLAMA_MODEL_NAME
    };
    let currentModelName = 'JARVIS Pro';
    
    // --- Memory and Conversation Storage ---
    let conversationHistory = JSON.parse(localStorage.getItem('jarvis-conversation') || '[]');
    let savedMemory = JSON.parse(localStorage.getItem('jarvis-memory') || '[]');
    
    // --- DOM Elements ---
    const chatBox = document.getElementById('chat-box');
    const userInput = document.getElementById('user-input');
    const micBtn = document.getElementById('mic-btn');
    const waveformCanvas = document.getElementById('waveform-canvas');
    const startOverlay = document.getElementById('start-overlay');
    const micPermissionOverlay = document.getElementById('mic-permission-overlay');
    const grantMicBtn = document.getElementById('grant-mic-btn');
    const statusDot = document.getElementById('status-dot');
    const statusText = document.getElementById('status-text');
    const currentTime = document.getElementById('current-time');
    const currentDate = document.getElementById('current-date');
    const memoryCount = document.getElementById('memory-count');
    const chatCount = document.getElementById('chat-count');
    const micStatus = document.getElementById('mic-status');
    const clearChatBtn = document.getElementById('clear-chat-btn');
    const modelToggleBtn = document.getElementById('model-toggle-btn');
    const mediaPlayerContainer = document.getElementById('media-player-container');
    const mediaInfo = document.getElementById('media-info');
    const closePlayerBtn = document.getElementById('close-player-btn');
    const playPauseBtn = document.getElementById('play-pause-btn');
    const seekBackwardBtn = document.getElementById('seek-backward-btn');
    const seekForwardBtn = document.getElementById('seek-forward-btn');
    const selfDestructSound = document.getElementById('self-destruct-sound');
    const destructionOverlay = document.getElementById('destruction-overlay');
    const jarvisContainer = document.querySelector('.jarvis-container');

    const startSound = document.getElementById('start-sound');
    const endSound = document.getElementById('end-sound');
    
    // --- Vision DOM Elements (NEW) ---
    const visionOverlay = document.getElementById('vision-overlay');
    const visionFeed = document.getElementById('vision-feed');
    const visionCanvas = document.getElementById('vision-canvas');
    const visionStatus = document.getElementById('vision-status');
    const scanStartSound = document.getElementById('scan-start-sound');
    const scanCompleteSound = document.getElementById('scan-complete-sound');

    // --- Original Face Auth DOM Elements (Retained for login flow) ---
    const faceAuthOverlay = document.getElementById('face-auth-overlay');
    const webcamFeed = document.getElementById('webcam-feed');
    const scanLine = document.getElementById('scan-line');
    const authStatus = document.getElementById('auth-status');
    
    let speakingAnimation = null;
    let isAwaitingSupportQuery = false;
    let isVisionScanning = false; // NEW state
    let scanAnimationId = null; // NEW state
    let visionStream = null; // NEW state
    let audioStream = null;
    let microphoneGranted = false;


    // --- YouTube Player Logic (RESTORED) ---
    let ytPlayer;
    let isPlayerReady = false;
    let isMusicPlaying = false; 

    function onPlayerError(event) {
        console.error("YouTube Player Error:", event.data);
        stopMediaPlayer(); 
        const videoUrl = ytPlayer.getVideoUrl();
        if (videoUrl && videoUrl.includes('watch?v=')) {
            window.open(videoUrl, '_blank'); 
            const errorMessage = "Sir, that video is restricted from playing here. I have opened it for you in a new tab on YouTube instead.";
            addMessage(errorMessage, 'jarvis');
            speak(errorMessage);
        } else {
             const genericError = "Sir, an unknown error occurred with the media player.";
             addMessage(genericError, 'jarvis');
             speak(genericError);
        }
    }

    function onPlayerStateChange(event) {
        if (event.data == YT.PlayerState.PLAYING) {
            playPauseBtn.textContent = 'PAUSE';
        } else if (event.data == YT.PlayerState.PAUSED) {
            playPauseBtn.textContent = 'PLAY';
        } else if (event.data == YT.PlayerState.ENDED) {
            stopMediaPlayer();
            const endMessage = "Media finished, sir. Closing the player.";
            addMessage(endMessage, 'jarvis');
            speak(endMessage);
        }
    }

    window.onYouTubeIframeAPIReady = function() {
        ytPlayer = new YT.Player('youtube-player', {
            height: '100%',
            width: '100%',
            playerVars: { 
                'playsinline': 1, 
                'autoplay': 1, 
                'controls': 0, 
                'rel': 0, 
                'modestbranding': 1 
            },
            events: {
                'onReady': () => { 
                    console.log("YouTube Player is Ready.");
                    isPlayerReady = true; 
                },
                'onStateChange': onPlayerStateChange,
                'onError': onPlayerError
            }
        });
    };

    async function findYouTubeMedia(query) {
        try {
            const searchUrl = `${GOOGLE_SEARCH_URL}&q=${encodeURIComponent(query + " site:youtube.com")}&num=1`;
            const response = await fetch(searchUrl);
            if (!response.ok) throw new Error(`Search API error: ${response.statusText}`);
            const data = await response.json();

            if (data.items && data.items.length > 0) {
                const item = data.items[0];
                if (item.link.includes("watch?v=")) {
                     const videoId = new URL(item.link).searchParams.get('v');
                     if (videoId) return { id: videoId, title: item.title, url: item.link };
                }
            }
            return null;
        } catch (error) {
            console.error("YouTube media search error:", error);
            return null;
        }
    }

    async function playMedia(query) {
        if (!isPlayerReady) {
            addMessage("Sir, the media player is still initializing. Please try again in a moment.", 'jarvis');
            speak("Sir, the media player is still initializing. Please try again in a moment.");
            return;
        }
        updateStatus("Searching YouTube...");
        const searchMessage = addMessage(`Searching YouTube for "${query}"...`, 'jarvis');
        searchMessage.classList.add('searching');
        const media = await findYouTubeMedia(query);
        chatBox.removeChild(searchMessage);

        if (media && ytPlayer) {
            mediaPlayerContainer.classList.add('visible');
            mediaInfo.textContent = media.title.replace(/ - YouTube$/, '');
            ytPlayer.loadVideoById(media.id);
            playPauseBtn.textContent = 'PAUSE'; 
            
            isMusicPlaying = true;
            waveformCanvas.classList.add('visible');

            addMessage(`Attempting to play: ${media.title.replace(/ - YouTube$/, '')}`, 'jarvis');
            speak(`Attempting to play: ${media.title.replace(/ - YouTube$/, '')}`);
        } else {
            addMessage(`Sir, I was unable to find a suitable video for "${query}".`, 'jarvis');
            speak(`Sir, I was unable to find a suitable video for "${query}".`);
        }
        updateStatus("System Ready");
    }
    
    async function openYouTubeChannel(channelName) {
         updateStatus("Searching for channel...");
         const searchMessage = addMessage(`Searching for the channel "${channelName}"...`, 'jarvis');
         searchMessage.classList.add('searching');
         try {
            const searchQuery = `${channelName} YouTube channel page site:youtube.com`;
            const searchUrl = `${GOOGLE_SEARCH_URL}&q=${encodeURIComponent(searchQuery)}&num=1`;
            const response = await fetch(searchUrl);
            if (!response.ok) throw new Error(`Search API error: ${response.statusText}`);
            const data = await response.json();
            chatBox.removeChild(searchMessage);
            if (data.items && data.items.length > 0) {
                const item = data.items[0];
                if (item.link.includes('/channel/') || item.link.includes('/c/') || item.link.includes('/@')) {
                    window.open(item.link, '_blank');
                    addMessage(`Opening the channel for ${channelName}, sir.`, 'jarvis');
                    speak(`Opening the channel for ${channelName}, sir.`);
                } else { throw new Error("Best result was not a channel page."); }
            } else { throw new Error("No results found."); }
         } catch (error) {
            chatBox.removeChild(searchMessage);
            console.error("Channel search error:", error);
            addMessage(`Sir, I was unable to locate the YouTube channel for "${channelName}".`, 'jarvis');
            speak(`Sir, I was unable to locate the YouTube channel for "${channelName}".`);
         }
         updateStatus("System Ready");
    }

    function composeWhatsAppMessage(recipientPhone, message) {
        const cleanPhoneNumber = recipientPhone.replace(/[\s-()]/g, '');
        if (!/^\+?\d+$/.test(cleanPhoneNumber)) {
             const errorMsg = "Sir, that does not appear to be a valid phone number. Please include the country code, for example, +91.";
             addMessage(errorMsg, 'jarvis');
             speak(errorMsg);
             return;
        }
        const whatsappUrl = `https://wa.me/${cleanPhoneNumber.replace('+', '')}?text=${encodeURIComponent(message)}`;
        window.open(whatsappUrl, '_blank');
        const successMsg = `Opening WhatsApp for your message to ${recipientPhone}, sir. Please press send to confirm.`;
        addMessage(successMsg, 'jarvis');
        speak(successMsg);
    }

    function stopMediaPlayer() {
        if (ytPlayer && typeof ytPlayer.stopVideo === 'function') {
            ytPlayer.stopVideo();
        }
        mediaPlayerContainer.classList.remove('visible');
        playPauseBtn.textContent = 'PLAY'; 
        
        isMusicPlaying = false;
        if (!micBtn.classList.contains('listening')) {
            waveformCanvas.classList.remove('visible');
        }
    }

    // --- Microphone Permission Management (RESTORED) ---
    async function checkMicrophonePermission() {
        try {
            const permissionStatus = await navigator.permissions.query({ name: 'microphone' });
            updateMicStatus(permissionStatus.state);
            permissionStatus.onchange = () => updateMicStatus(permissionStatus.state);
            return permissionStatus.state === 'granted';
        } catch (error) {
            console.error('Error checking microphone permission:', error);
            return false;
        }
    }

    function updateMicStatus(status) {
        micStatus.textContent = status.charAt(0).toUpperCase() + status.slice(1);
        if (status === 'granted') {
            microphoneGranted = true;
            micBtn.disabled = false;
        } else if (status === 'denied') {
            microphoneGranted = false;
            micBtn.disabled = true;
            statusDot.classList.add('warning');
        } else {
            microphoneGranted = false;
            micBtn.disabled = false;
        }
    }

    async function requestMicrophoneAccess() {
        try {
            updateStatus("Requesting microphone access...");
            audioStream = await navigator.mediaDevices.getUserMedia({ 
                audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true } 
            });
            microphoneGranted = true;
            updateMicStatus('granted');
            updateStatus("Microphone access granted");
            setupAudioVisualizer(audioStream);
            return true;
        } catch (error) {
            console.error('Error accessing microphone:', error);
            microphoneGranted = false;
            updateMicStatus('denied');
            updateStatus("Microphone access denied", false);
            addMessage("Sir, I was unable to access the microphone. Please check your browser permissions.", 'jarvis');
            setTimeout(() => updateStatus("System Ready"), 3000);
            return false;
        }
    }

    function updateSystemInfo() {
        memoryCount.textContent = savedMemory.length;
        chatCount.textContent = conversationHistory.length;
    }

    function updateDateTime() {
        const now = new Date();
        currentTime.textContent = `Time: ${now.toLocaleTimeString()}`;
        currentDate.textContent = `Date: ${now.toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}`;
    }

    setInterval(updateDateTime, 1000);
    updateDateTime();
    
    // --- Speech & Voice (RESTORED) ---
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition;
    
    if (SpeechRecognition) {
        recognition = new SpeechRecognition();
        recognition.continuous = false;
        recognition.lang = 'en-US';
        recognition.interimResults = false;
    } else {
        console.error("Speech Recognition not supported in this browser.");
        micBtn.disabled = true;
        micStatus.textContent = "Not Supported";
    }
    
    // --- 3D Core Setup (RESTORED) ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('jarvis-core'), alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.position.z = 5;

    const vertexShaderSource = `
        uniform float u_time;
        uniform float u_scale;
        void main() {
            vec3 pos = position;
            float warp = sin(pos.y * 2.0 + u_time * 0.5) * 0.3 + 
                         cos(pos.x * 2.0 + u_time * 0.3) * 0.3;
            pos.z += warp;
            pos.x += cos(pos.z * 1.5 + u_time * 0.2) * 0.2;
            vec3 animatedPos = pos * u_scale;
            vec4 modelViewPosition = modelViewMatrix * vec4(animatedPos, 1.0);
            gl_Position = projectionMatrix * modelViewPosition;
            gl_PointSize = (10.0 / -modelViewPosition.z) * (u_scale * 0.5); 
        }
    `;

    const fragmentShaderSource = `
        uniform vec3 u_color;
        void main() {
            float strength = 1.0 - (distance(gl_PointCoord, vec2(0.5)) * 2.0);
            gl_FragColor = vec4(u_color, strength * 0.8);
        }
    `;

    const uniforms = {
        u_time: { value: 0.0 },
        u_color: { value: new THREE.Color(0x00d9ff) }, 
        u_scale: { value: 1.0 }
    };

    const particleCount = 10000;
    const positions = new Float32Array(particleCount * 3);
    for (let i = 0; i < particleCount; i++) {
        const iFloat = i + 0.5;
        const phi = Math.acos(1 - 2 * iFloat / particleCount);
        const theta = Math.PI * (1 + Math.sqrt(5)) * iFloat;
        const r = 2.5; 
        positions[i * 3] = r * Math.cos(theta) * Math.sin(phi);
        positions[i * 3 + 1] = r * Math.sin(theta) * Math.sin(phi);
        positions[i * 3 + 2] = r * Math.cos(phi);
    }
    const particleGeometry = new THREE.BufferGeometry();
    particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    
    const particleMaterial = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: vertexShaderSource,
        fragmentShader: fragmentShaderSource,
        blending: THREE.AdditiveBlending,
        transparent: true,
        depthWrite: false
    });

    const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
    scene.add(particleSystem);

    function animateCore() {
        requestAnimationFrame(animateCore);
        uniforms.u_time.value += 0.01;
        renderer.render(scene, camera);
    }
    animateCore();
    
    gsap.to(".ring-1", { rotation: 360, duration: 40, repeat: -1, ease: "none" });
    gsap.to(".ring-2", { rotation: -360, duration: 30, repeat: -1, ease: "none" });
    gsap.to(".ring-3", { rotation: 360, duration: 20, repeat: -1, ease: "none" });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // --- Audio Visualizer (RESTORED) ---
    let audioContext, analyser, dataArray, source;
    const waveformCtx = waveformCanvas.getContext('2d');
    let waveTime = 0; 
    
    function setupAudioVisualizer(stream = null) {
        if (!stream) return;
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            source = audioContext.createMediaStreamSource(stream);
            source.connect(analyser);
            analyser.fftSize = 256;
            const bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);
            
            startWaveformAnimation(); 
        } catch (err) { console.error(`Audio visualizer error: ${err}`); }
    }
    
    function startWaveformAnimation() {
        function animateWaveform() {
            requestAnimationFrame(animateWaveform);
            
            waveformCtx.clearRect(0, 0, waveformCanvas.width, waveformCanvas.height);
            
            if (isMusicPlaying) {
                drawMusicWaveform();
            } else if (analyser && micBtn.classList.contains('listening')) {
                drawMicrophoneWaveform();
            } else if (!isMusicPlaying && !micBtn.classList.contains('listening')) {
                if (uniforms.u_scale.value !== 1.0) {
                    gsap.to(uniforms.u_scale, { value: 1.0, duration: 0.5, ease: "power2.out" });
                }
            }
        }
        animateWaveform();
    }

    function drawMusicWaveform() {
        waveTime += 0.03; 
        const width = waveformCanvas.width;
        const height = waveformCanvas.height;
        const halfWidth = width / 2;
        const numBars = 32; 
        const barWidth = (width / 2) / numBars;

        const gradient = waveformCtx.createLinearGradient(0, 0, 0, height);
        gradient.addColorStop(0, "rgba(0, 217, 255, 0.8)"); 
        gradient.addColorStop(0.5, "rgba(0, 217, 255, 0.5)");
        gradient.addColorStop(1, "rgba(0, 217, 255, 0.2)");
        waveformCtx.fillStyle = gradient;

        for (let i = 0; i < numBars; i++) {
            let barHeight = Math.abs(Math.sin(i * 0.2 + waveTime) * height * 0.6) +
                            Math.abs(Math.sin(i * 0.05 + waveTime * 0.5) * height * 0.4);
            
            let globalPulse = Math.sin(waveTime * 2.0) * 0.2 + 0.8; 
            barHeight *= globalPulse;
            
            barHeight = Math.max(2, barHeight); 

            waveformCtx.fillRect(halfWidth + i * barWidth, height - barHeight, barWidth * 0.8, barHeight); 
            waveformCtx.fillRect(halfWidth - (i + 1) * barWidth, height - barHeight, barWidth * 0.8, barHeight); 
        }
        
        const musicScale = 1.0 + Math.abs(Math.sin(waveTime * 2.0)) * 0.2; 
        gsap.to(uniforms.u_scale, { value: musicScale, duration: 0.1 });
    }

    function drawMicrophoneWaveform() {
        if (!analyser) return;
        analyser.getByteFrequencyData(dataArray);
        
        const average = dataArray.reduce((acc, val) => acc + val, 0) / dataArray.length;
        const scale = 1 + (average / 256) * 0.5; 
        
        gsap.to(uniforms.u_scale, { value: scale, duration: 0.1 });

        const barWidth = (waveformCanvas.width / dataArray.length) * 1.5;
        let x = 0;
        const gradient = waveformCtx.createLinearGradient(0, 0, 0, waveformCanvas.height);
        gradient.addColorStop(0, "rgba(0, 217, 255, 0.8)");
        gradient.addColorStop(0.5, "rgba(0, 217, 255, 0.5)");
        gradient.addColorStop(1, "rgba(0, 217, 255, 0.2)");
        waveformCtx.fillStyle = gradient;
        
        for(let i = 0; i < dataArray.length; i++) {
            const barHeight = dataArray[i] / 2;
            waveformCtx.fillRect(x, waveformCanvas.height - barHeight, barWidth, barHeight);
            x += barWidth + 1;
        }
    }

    // --- Core Functions (RESTORED) ---
    let jarvisVoice = null;
    let voiceInitializationPromise = null;

    function initializeSpeech() {
        if (voiceInitializationPromise) return voiceInitializationPromise;

        voiceInitializationPromise = new Promise((resolve) => {
            const findAndSetVoice = () => {
                const voices = speechSynthesis.getVoices();
                if (voices.length > 0) {
                    jarvisVoice = voices.find(voice => voice.name.includes('Google UK English Male')) || voices.find(voice => voice.name.includes('David') && voice.lang.includes('en')) || voices.find(voice => voice.lang === 'en-GB' && voice.name.toLowerCase().includes('male')) || voices.find(voice => voice.lang === 'en-US' && voice.name.toLowerCase().includes('male')) || voices.find(voice => voice.lang.startsWith('en-'));
                    console.log("J.A.R.V.I.S. voice selected:", jarvisVoice ? `${jarvisVoice.name} (${jarvisVoice.lang})` : "Default voice");
                    resolve();
                }
            };

            findAndSetVoice();
            if (speechSynthesis.onvoiceschanged !== undefined) {
                speechSynthesis.onvoiceschanged = findAndSetVoice;
            }
        });
        return voiceInitializationPromise;
    }

    function updateStatus(status, isOnline = true) {
        statusText.textContent = status;
        statusDot.classList.toggle('offline', !isOnline);
        statusDot.classList.remove('warning');
    }

    function cleanTextForSpeech(text) {
        return text.replace(/```[\s\S]*?```/g, 'Code block follows.').replace(/\*\*|\*|#|_|`|\[.*?\]|\(.*?\)/g, '').replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
    }

    async function speak(text) {
        await initializeSpeech(); 
        speechSynthesis.cancel();
        
        if (speakingAnimation) speakingAnimation.kill();

        const cleanText = cleanTextForSpeech(text);
        const finalText = (!text.includes("At your service") && !text.toLowerCase().startsWith("sir") && !text.toLowerCase().includes(" sir") && !text.toLowerCase().endsWith("sir") && !text.toLowerCase().includes("welcome back")) ? "Sir, " + cleanText : cleanText;
        const utterance = new SpeechSynthesisUtterance(finalText);
        if (jarvisVoice) utterance.voice = jarvisVoice;
        utterance.pitch = 1.0;
        utterance.rate = 1.05;
        utterance.volume = 1.0;
        
        return new Promise((resolve, reject) => {
            utterance.onstart = () => {
                updateStatus("Speaking");
                if (endSound) endSound.play().catch(e => console.error("End sound error:", e));
                speakingAnimation = gsap.to(uniforms.u_scale, { value: 1.2, duration: 0.5, yoyo: true, repeat: -1, ease: "power1.inOut" });
            };
            utterance.onend = () => {
                updateStatus("System Ready");
                if (speakingAnimation) speakingAnimation.kill();
                gsap.to(uniforms.u_scale, { value: 1, duration: 0.3 });
                resolve();
            };
            utterance.onerror = (e) => {
                console.error("Speech synthesis error:", e);
                updateStatus("Speech Error", false);
                reject(e);
            };
            speechSynthesis.speak(utterance);
        });
    }

    function addMessage(text, sender) {
        const messageDiv = document.createElement('div');
        messageDiv.classList.add('chat-message', `${sender}-message`);
        messageDiv.textContent = text.trim();
        chatBox.appendChild(messageDiv);
        chatBox.scrollTop = chatBox.scrollHeight;
        return messageDiv;
    }

    function clearChat() {
        chatBox.innerHTML = '';
        conversationHistory = [];
        localStorage.setItem('jarvis-conversation', JSON.stringify(conversationHistory));
        updateSystemInfo();
        const clearedMessage = "Sir, I've cleared our conversation. Starting fresh.";
        addMessage(clearedMessage, 'jarvis');
        speak(clearedMessage);
    }

    function saveToMemory(info, category = 'general') {
        const memoryItem = { id: Date.now(), content: info, category: category, timestamp: new Date().toISOString() };
        savedMemory.push(memoryItem);
        localStorage.setItem('jarvis-memory', JSON.stringify(savedMemory));
        updateSystemInfo();
        return memoryItem;
    }

    function getFromMemory(query = '') {
        if (!query) return savedMemory.slice(-5);
        const searchTerm = query.toLowerCase();
        return savedMemory.filter(item => item.content.toLowerCase().includes(searchTerm) || item.category.toLowerCase().includes(searchTerm));
    }
    
    async function sendSupportQuery(queryText) {
        updateStatus("Sending support query...");
        const statusMessage = addMessage("Sending your query to support...", 'jarvis');
        statusMessage.classList.add('thinking');
        try {
            // NOTE: You must update the email here for this feature to work!
            const response = await fetch('https://formsubmit.co/ajax/your-email@example.com', { 
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                body: JSON.stringify({ _subject: "New Support Query from J.A.R.V.I.S. Interface", message: queryText })
            });
            if (!response.ok) { throw new Error('Form submission failed.'); }
            chatBox.removeChild(statusMessage);
            addMessage("Sir, your query has been successfully sent. How may I help you further?", 'jarvis');
            speak("Sir, your query has been successfully sent. How may I help you further?");
            updateStatus("System Ready");
        } catch (error) {
            console.error("Error sending support query:", error);
            chatBox.removeChild(statusMessage);
            addMessage("Sir, I encountered an error while sending your query. Please try again later.", 'jarvis');
            speak("Sir, I encountered an error while sending your query. Please try again later.");
            updateStatus("Error", false);
            setTimeout(() => updateStatus("System Ready"), 3000);
        }
    }
    
    // --- NEW: Object Detection Core Logic ---
    const MOCK_OBJECTS = [
        "Computer Monitor", "Desk Chair", "Coffee Mug", "Mobile Phone", 
        "Human Hand", "Keyboard", "Water Bottle", "Book Shelf"
    ];

    async function startVisionScan() {
        if (isVisionScanning) return;
        isVisionScanning = true;
        
        // Disable inputs and UI elements
        userInput.disabled = true;
        micBtn.disabled = true;
        clearChatBtn.disabled = true;
        modelToggleBtn.disabled = true;
        jarvisContainer.style.display = 'none';
        
        // Open Vision Overlay
        visionOverlay.style.display = 'flex';
        visionCanvas.width = window.innerWidth;
        visionCanvas.height = window.innerHeight;
        gsap.fromTo(visionOverlay, {opacity: 0}, {opacity: 1, duration: 0.5});
        
        try {
            // Request Camera Access
            visionStatus.textContent = "Initiating Visual Recognition System...";
            visionStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: false });
            visionFeed.srcObject = visionStream;
            
            // Start Scan Audio and Status
            scanStartSound.currentTime = 0;
            scanStartSound.loop = true;
            scanStartSound.play().catch(e => console.error("Scan sound error:", e));
            visionStatus.textContent = "Scanning for Objects...";
            
            let scanProgress = 0; 
            let scanDuration = 5000; 
            const scanStartTime = Date.now();
            
            const visionCtx = visionCanvas.getContext('2d');
            
            const animateScanner = () => {
                const elapsed = Date.now() - scanStartTime;
                scanProgress = Math.min(100, (elapsed / scanDuration) * 100);

                visionCtx.clearRect(0, 0, visionCanvas.width, visionCanvas.height);

                const cx = visionCanvas.width / 2;
                const cy = visionCanvas.height / 2;
                const maxRadius = Math.min(cx, cy) * 0.7; 
                const scanRadius = maxRadius * (0.8 + Math.sin(Date.now() * 0.005) * 0.2); // Pulsing effect

                // Draw the main scanning circle
                visionCtx.beginPath();
                visionCtx.arc(cx, cy, scanRadius, 0, 2 * Math.PI);
                visionCtx.strokeStyle = 'rgba(0, 217, 255, 0.7)';
                visionCtx.lineWidth = 4;
                visionCtx.shadowBlur = 15;
                visionCtx.shadowColor = 'rgba(0, 217, 255, 1)';
                visionCtx.stroke();
                
                // Draw the animated sweep line
                const sweepAngle = (scanProgress / 100) * (Math.PI * 4); 
                visionCtx.beginPath();
                visionCtx.arc(cx, cy, scanRadius, 0, sweepAngle, false);
                visionCtx.lineTo(cx, cy);
                visionCtx.closePath();
                visionCtx.fillStyle = 'rgba(0, 217, 255, 0.1)'; 
                visionCtx.fill();

                // Draw the "target" crosshair
                const crosshairSize = scanRadius * 0.05;
                visionCtx.strokeStyle = 'rgba(0, 217, 255, 1)';
                visionCtx.lineWidth = 2;
                visionCtx.shadowBlur = 0;
                visionCtx.beginPath();
                visionCtx.moveTo(cx - crosshairSize, cy);
                visionCtx.lineTo(cx + crosshairSize, cy);
                visionCtx.moveTo(cx, cy - crosshairSize);
                visionCtx.lineTo(cx, cy + crosshairSize);
                visionCtx.stroke();


                if (scanProgress < 100) {
                    scanAnimationId = requestAnimationFrame(animateScanner);
                } else {
                    cancelAnimationFrame(scanAnimationId);
                    completeVisionScan(visionStream);
                }
            };
            animateScanner();
            
        } catch (error) {
            console.error("Vision system error:", error);
            visionStatus.textContent = "ERROR: Camera access denied. Closing system.";
            scanStartSound.pause();
            await speak("Sir, I was unable to access the visual sensor array. Access denied.");
            
            await new Promise(resolve => setTimeout(resolve, 2000));
            stopVisionScan(visionStream);
        }
    }
    
    async function completeVisionScan(stream) {
        scanStartSound.pause();
        scanCompleteSound.currentTime = 0;
        scanCompleteSound.play().catch(e => console.error("Completion sound error:", e));

        const objectName = MOCK_OBJECTS[Math.floor(Math.random() * MOCK_OBJECTS.length)];
        visionStatus.textContent = `OBJECT DETECTED: ${objectName}`;
        
        const response = `Sir, the object has been identified as a ${objectName}.`;
        await speak(response);
        addMessage(response, 'jarvis');

        // Draw a persistent bounding box and label before closing
        const visionCtx = visionCanvas.getContext('2d');
        const cx = visionCanvas.width / 2;
        const cy = visionCanvas.height / 2;
        const size = Math.min(cx, cy) * 0.5;

        // Draw Bounding Box
        visionCtx.strokeStyle = 'rgba(0, 255, 0, 1)';
        visionCtx.lineWidth = 3;
        visionCtx.shadowBlur = 10;
        visionCtx.shadowColor = 'rgba(0, 255, 0, 1)';
        visionCtx.strokeRect(cx - size/2, cy - size/2, size, size);

        // Draw Label
        visionCtx.font = "20px 'Orbitron'";
        visionCtx.fillStyle = 'rgba(0, 255, 0, 1)';
        visionCtx.textAlign = 'center';
        visionCtx.fillText(objectName, cx, cy - size/2 - 15);
        
        await new Promise(resolve => setTimeout(resolve, 2000)); // Hold result for 2 seconds

        stopVisionScan(stream);
    }

    function stopVisionScan(stream) {
        isVisionScanning = false;
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
            visionStream = null;
        }

        gsap.to(visionOverlay, {opacity: 0, duration: 0.5, onComplete: () => {
            visionOverlay.style.display = 'none';
            visionStatus.textContent = "Scanning for Objects..."; 
            // Re-enable all inputs
            userInput.disabled = false;
            checkMicrophonePermission(); 
            clearChatBtn.disabled = false;
            modelToggleBtn.disabled = false;
            jarvisContainer.style.display = 'flex';
        }});
    }
    
    // --- Command Processing (RESTORED and UPDATED) ---
    function processSpecialCommands(prompt) {
        const lowerPrompt = prompt.toLowerCase();
        
        const whatsappRegex = /send (?:a )?whatsapp(?: message)? to (\+?\d+[\d\s-()]*\d) (?:saying|that says|with the message|then comes the message|message) (.*)/i;
        const whatsappMatch = prompt.match(whatsappRegex);
        if (whatsappMatch) {
            return { type: 'send_whatsapp', phone: whatsappMatch[1].trim(), message: whatsappMatch[2].trim() };
        }

        if (['self destruct', 'destroy yourself', 'initiate self-destruct', 'go boom'].some(term => lowerPrompt.includes(term))) {
            return { type: 'self_destruct' };
        }
        
        if (['scan object', 'identify this', 'what is this'].some(term => lowerPrompt.includes(term))) {
            return { type: 'scan_object' };
        }

        if (lowerPrompt.startsWith('play ')) {
            const query = prompt.substring('play'.length).trim();
            if (query) return { type: 'play_media', query: query };
        }
        if (lowerPrompt.includes('open the youtube channel of')) {
            const channelName = prompt.replace(/open the youtube channel of/i, '').trim();
            if (channelName) return { type: 'open_channel', query: channelName };
        }
        if (['stop music', 'stop video', 'stop the music', 'close player'].includes(lowerPrompt)) {
            stopMediaPlayer();
            return "As you wish, sir. The player is closed.";
        }
        if (['clear chat', 'clear conversation', 'start over'].some(term => lowerPrompt.includes(term))) {
            clearChat();
            return "CLEAR_CHAT";
        }
        if (['contact support', 'support query'].some(term => lowerPrompt.includes(term))) {
            isAwaitingSupportQuery = true;
            return "Sure sir, please tell me your query.";
        }
        if (['time', 'what time is it', 'current time'].includes(lowerPrompt)) {
            return `Sir, the current local time is ${new Date().toLocaleTimeString()}.`;
        }
        if (['date', "what's the date", "today's date"].includes(lowerPrompt)) {
            return `Sir, today is ${new Date().toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}.`;
        }
        
        // --- Expanded App Opening Commands (RESTORED) ---
        if (lowerPrompt === 'open youtube') { window.open('https://www.youtube.com', '_blank'); return "Opening YouTube, sir."; }
        if (lowerPrompt.startsWith('google search for ') || lowerPrompt.startsWith('search for ')) {
            const query = prompt.replace(/^(google search for|search for)\s*/i, '').trim();
            if (query) { window.open(`https://www.google.com/search?q=${encodeURIComponent(query)}`, '_blank'); return `Searching Google for "${query}", sir.`; }
        }
        if (lowerPrompt === 'open a new tab') { window.open('', '_blank'); return 'New tab opened, sir.'; }
        if (lowerPrompt.includes('open gmail')) { window.open('https://mail.google.com', '_blank'); return "Opening Gmail for you, sir."; }
        if (lowerPrompt.includes('open word')) { window.open('https://word.office.com', '_blank'); return "Opening Microsoft Word Online, sir."; }
        if (lowerPrompt.includes('open excel')) { window.open('https://excel.office.com', '_blank'); return "Opening Microsoft Excel Online, sir."; }
        if (lowerPrompt.includes('open powerpoint')) { window.open('https://powerpoint.office.com', '_blank'); return "Opening Microsoft PowerPoint Online, sir."; }
        if (lowerPrompt.includes('open outlook')) { window.open('https://outlook.live.com', '_blank'); return "Opening Outlook, sir."; }
        if (lowerPrompt.includes('open teams') || lowerPrompt.includes('open microsoft teams')) { window.open('https://teams.microsoft.com', '_blank'); return "Opening Microsoft Teams, sir."; }
        if (lowerPrompt.includes('open onedrive')) { window.open('https://onedrive.live.com', '_blank'); return "Opening OneDrive, sir."; }
        if (lowerPrompt.includes('open spotify')) { window.open('https://open.spotify.com', '_blank'); return "Opening the Spotify web player, sir."; }
        if (lowerPrompt.includes('open netflix')) { window.open('https://www.netflix.com', '_blank'); return "Opening Netflix, sir."; }
        if (lowerPrompt.includes('open maps') || lowerPrompt.includes('open google maps')) { window.open('https://maps.google.com', '_blank'); return "Opening Google Maps, sir."; }
        if (lowerPrompt.includes('open wikipedia')) { window.open('https://www.wikipedia.org', '_blank'); return "Opening Wikipedia, sir."; }
        if (lowerPrompt.includes('open github')) { window.open('https://www.github.com', '_blank'); return "Opening GitHub, sir."; }
        if (lowerPrompt.includes('open facebook')) { window.open('https://www.facebook.com', '_blank'); return "Opening Facebook, sir."; }
        if (lowerPrompt.includes('open twitter') || lowerPrompt.includes('open x.com')) { window.open('https://www.x.com', '_blank'); return "Opening X (formerly Twitter), sir."; }
        if (lowerPrompt.includes('open instagram')) { window.open('https://www.instagram.com', '_blank'); return "Opening Instagram, sir."; }
        if (lowerPrompt.includes('open linkedin')) { window.open('https://www.linkedin.com', '_blank'); return "Opening LinkedIn, sir."; }
        if (['open a notepad', 'online notepad', 'open notepad'].includes(lowerPrompt)) { window.open('https://anotepad.com/', '_blank'); return "I've opened an online notepad for you, sir."; }
        // --- End Expanded Commands ---

        if (['save this', 'remember this', 'store this'].some(term => lowerPrompt.startsWith(term))) {
            const content = prompt.replace(/^(save this|remember this|store this)\s*/i, '').trim();
            if (content) {
                const saved = saveToMemory(content, 'user-request');
                return `Sir, I've saved that information. Reference ID: ${saved.id}`;
            }
        }
        if (lowerPrompt.startsWith('what did i tell you about') || lowerPrompt.startsWith('recall')) {
            const searchTerm = prompt.replace(/^(what did i tell you about|recall)\s*/i, '').trim();
            const memories = getFromMemory(searchTerm);
            if (memories.length > 0) {
                const memoryText = memories.map(m => `On ${new Date(m.timestamp).toLocaleDateString()}: ${m.content}`).join('\n');
                // The AI handles the full recall in the system prompt, but for instant, non-AI answers:
                return `Sir, here's what I recall about "${searchTerm}":\n${memoryText}`;
            } else {
                return `Sir, I have no saved information about "${searchTerm}".`;
            }
        }
        return null;
    }
    
    // --- Self-Destruct Function (RESTORED) ---
    async function initiateSelfDestruct() {
        userInput.disabled = true;
        micBtn.disabled = true;
        clearChatBtn.disabled = true;
        modelToggleBtn.disabled = true;

        stopMediaPlayer();
        speechSynthesis.cancel(); 

        const response = "I have been glad to serve you, sir. Initiating self-destruct sequence. Goodbye.";
        addMessage(response, 'jarvis');
        await speak(response); 

        try {
            selfDestructSound.currentTime = 0; 
            selfDestructSound.play();
        } catch (error) {
            console.error("Self-destruct audio failed to play:", error);
            addMessage("Audio playback error. Proceeding with visual destruction.", 'jarvis');
        }

        setTimeout(() => {
            destructionOverlay.style.display = 'flex';
            gsap.to(destructionOverlay, { 
                opacity: 1, 
                duration: 0.1, 
                onComplete: () => {
                    jarvisContainer.classList.add('shake');
                    destructionOverlay.classList.add('active');
                    jarvisContainer.style.display = 'none';
                    
                    setTimeout(() => {
                        gsap.to(destructionOverlay, { 
                            opacity: 0, 
                            duration: 1.0, 
                            onComplete: () => {
                                destructionOverlay.style.display = 'none';
                                destructionOverlay.classList.remove('active');
                                jarvisContainer.classList.remove('shake');
                                jarvisContainer.style.display = 'flex'; 
                                
                                userInput.disabled = false;
                                checkMicrophonePermission(); 
                                clearChatBtn.disabled = false;
                                modelToggleBtn.disabled = false;
                                
                                const rebootMsg = "System reboot complete. All functions back online.";
                                addMessage(rebootMsg, 'jarvis');
                                speak(rebootMsg);
                            }
                        });
                    }, 5000); 
                }
            });
        }, 19000);
    }

    // --- AI Response (RESTORED and ENHANCED with memory) ---
    async function getAIResponse(prompt) {
        updateStatus("Processing...");
        if (isAwaitingSupportQuery && !processSpecialCommands(prompt)) {
            isAwaitingSupportQuery = false;
            await sendSupportQuery(prompt);
            return;
        }
        
        const specialResponse = processSpecialCommands(prompt);
        if (specialResponse === "CLEAR_CHAT") return;
        
        const actionMap = {
            'play_media': playMedia,
            'open_channel': openYouTubeChannel,
            'send_whatsapp': (params) => composeWhatsAppMessage(params.phone, params.message),
            'self_destruct': initiateSelfDestruct,
            'scan_object': startVisionScan 
        };

        if (specialResponse && actionMap[specialResponse.type]) {
            if (specialResponse.type === 'self_destruct' || specialResponse.type === 'scan_object') {
                await actionMap[specialResponse.type]();
            } else {
                const params = specialResponse.type === 'send_whatsapp' ? specialResponse : specialResponse.query;
                await actionMap[specialResponse.type](params);
            }
            conversationHistory.push({ role: 'user', content: prompt });
            localStorage.setItem('jarvis-conversation', JSON.stringify(conversationHistory));
            updateSystemInfo();
            return;
        }
        
        if (specialResponse && typeof specialResponse === 'string') {
            addMessage(specialResponse, 'jarvis');
            speak(specialResponse);
            if (!isAwaitingSupportQuery) {
                conversationHistory.push({ role: 'user', content: prompt }, { role: 'assistant', content: specialResponse });
                localStorage.setItem('jarvis-conversation', JSON.stringify(conversationHistory));
            }
            updateSystemInfo();
            return;
        }

        const thinkingMessage = addMessage("Analyzing...", 'jarvis');
        thinkingMessage.classList.add('thinking');

        try {
            const messages = conversationHistory.slice(-10).map(msg => `${msg.role === 'user' ? 'USER' : 'ASSISTANT'}: ${msg.content}`).join('\n');
            const relevantMemories = getFromMemory(prompt).slice(0, 3);
            
            const systemPrompt = `You are J.A.R.V.I.S. (Just A Rather Very Intelligent System), a sophisticated AI assistant.
- Your persona is professional, concise, slightly formal, and immensely capable. Always address the user as "Sir".
- **Specialization & Personalization**: You must leverage the 'Current relevant memories' provided to give highly specialized, personalized answers and show that you have learned.
- Never use markdown formatting (like **, *, #, etc.). Keep responses clean for text-to-speech.
- Current date: ${new Date().toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}.
- Current relevant memories: ${relevantMemories.length > 0 ? relevantMemories.map(m => `"${m.content}"`).join(', ') : 'None'}`;
            
            const finalPrompt = `${systemPrompt}\n\n--- Conversation History ---\n${messages}\n\nUSER: ${prompt}\nASSISTANT:`;

            const modelToUse = MODELS[currentModelName];

            const response = await fetch(OLLAMA_API_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    model: modelToUse,
                    prompt: finalPrompt,
                    stream: false, 
                    options: { temperature: 0.8, top_k: 40, top_p: 0.95 }
                })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                const errorMessage = errorData.error || response.statusText;
                throw new Error(`Ollama API error: ${errorMessage}. Ensure Ollama is running and the model '${modelToUse}' is pulled.`);
            }
            const data = await response.json();
            
            if (!data.response) { throw new Error("No 'response' field in the Ollama output."); }

            let aiText = data.response.trim();
            chatBox.removeChild(thinkingMessage);
            addMessage(aiText, 'jarvis');
            speak(aiText);
            
            conversationHistory.push({ role: 'user', content: prompt }, { role: 'assistant', content: aiText });
            if (conversationHistory.length > 50) conversationHistory = conversationHistory.slice(-50);
            localStorage.setItem('jarvis-conversation', JSON.stringify(conversationHistory));
            updateSystemInfo();

        } catch (error) {
            console.error("Error fetching AI response:", error);
            chatBox.removeChild(thinkingMessage);
            const errorMessage = `Sir, I've encountered a processing error. Please ensure the Ollama server is running locally on port 11434 with model '${OLLAMA_MODEL_NAME}' pulled. Details: ${error.message}`;
            addMessage(errorMessage, 'jarvis');
            speak(errorMessage);
            updateStatus("API Error", false);
            setTimeout(() => updateStatus("System Ready"), 3000);
        }
    }
    
    function handleUserInput() {
        const text = userInput.value.trim();
        if (text) {
            addMessage(text, 'user');
            getAIResponse(text);
            userInput.value = '';
        }
    }

    async function handleMicClick() {
        if (!recognition) return addMessage("Sir, speech recognition is not supported in your browser.", 'jarvis');
        if (micBtn.classList.contains('listening')) return recognition.stop();
        if (!microphoneGranted) return micPermissionOverlay.style.display = 'flex';
        try {
            recognition.start();
        } catch (error) {
            console.error("Error starting speech recognition:", error);
            addMessage("Sir, there was an error starting voice recognition.", 'jarvis');
        }
    }

    // --- Event Listeners (RESTORED) ---
    if(recognition) {
        micBtn.addEventListener('click', handleMicClick);
        recognition.onstart = () => {
            micBtn.classList.add('listening');
            waveformCanvas.classList.add('visible'); 
            updateStatus("Listening...");
            if (startSound) startSound.play().catch(e => console.error("Start sound error:", e));
        };
        recognition.onresult = (event) => {
            const transcript = event.results[0][0].transcript;
            addMessage(transcript, 'user');
            getAIResponse(transcript);
        };
        recognition.onend = () => {
            micBtn.classList.remove('listening');
            if (!isMusicPlaying) {
                waveformCanvas.classList.remove('visible');
            }
            updateStatus("Processing voice input...");
        };
        recognition.onerror = (event) => {
            console.error("Speech recognition error:", event.error);
            addMessage(`Sir, recognition error: ${event.error}`, 'jarvis');
            updateStatus("Speech Error", false);
            setTimeout(() => updateStatus("System Ready"), 3000);
        };
    }
    
    userInput.addEventListener('keydown', (event) => { if (event.key === 'Enter') handleUserInput(); });
    clearChatBtn.addEventListener('click', clearChat);
    closePlayerBtn.addEventListener('click', () => {
        stopMediaPlayer();
        addMessage("Player closed, sir.", 'jarvis');
        speak("Player closed, sir.");
    });

    playPauseBtn.addEventListener('click', () => {
        if (!ytPlayer || typeof ytPlayer.getPlayerState !== 'function') return;
        const state = ytPlayer.getPlayerState();
        if (state === YT.PlayerState.PLAYING || state === YT.PlayerState.BUFFERING) {
            ytPlayer.pauseVideo();
        } else {
            ytPlayer.playVideo();
        }
    });

    seekBackwardBtn.addEventListener('click', () => {
        if (!ytPlayer || typeof ytPlayer.getCurrentTime !== 'function') return;
        const currentTime = ytPlayer.getCurrentTime();
        ytPlayer.seekTo(Math.max(0, currentTime - 10), true);
    });

    seekForwardBtn.addEventListener('click', () => {
        if (!ytPlayer || typeof ytPlayer.getCurrentTime !== 'function') return;
        const currentTime = ytPlayer.getCurrentTime();
        ytPlayer.seekTo(currentTime + 10, true);
    });

    modelToggleBtn.addEventListener('click', () => {
        currentModelName = currentModelName === 'JARVIS Pro' ? 'JARVIS Flash' : 'JARVIS Pro';
        modelToggleBtn.textContent = `Model: ${currentModelName}`;
        const feedbackMsg = `Sir, the model name has been updated to ${currentModelName}. I am currently using the local '${OLLAMA_MODEL_NAME}' model.`;
        addMessage(feedbackMsg, 'jarvis');
        speak(feedbackMsg);
    });

    grantMicBtn.addEventListener('click', async () => {
        const granted = await requestMicrophoneAccess();
        if (granted) {
            micPermissionOverlay.style.display = 'none';
            if (recognition) recognition.start();
        }
    });
    
    // --- Face Authentication and App Initialization (RESTORED) ---
    async function startFaceAuthentication() {
        // We skip the camera part for simplicity now and proceed to init main app
        // You can restore the camera/scan logic here if needed.
        await initializeSpeech();
        await speak("System Check Complete. Access granted.");
        await initializeMainApp(true);
        startOverlay.style.display = 'none'; // Ensure the start overlay is gone
    }

    async function initializeMainApp(isAuthenticated = false) {
        updateSystemInfo();
        const hasPermission = await checkMicrophonePermission();
        if (!hasPermission) {
            setTimeout(() => { micPermissionOverlay.style.display = 'flex'; }, 1000);
        } else {
            if (microphoneGranted) {
                try {
                    audioStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true } });
                    setupAudioVisualizer(audioStream);
                } catch (err) {
                    console.error("Silent mic access failed:", err);
                    updateMicStatus('prompt'); 
                }
            }
        }

        if (isAuthenticated || conversationHistory.length > 0) {
            conversationHistory.slice(-10).forEach(msg => addMessage(msg.content, msg.role === 'user' ? 'user' : 'jarvis'));
            const welcomeMsg = isAuthenticated ? "Welcome back, sir! How may I serve you today?" : "Sir, welcome back. I have loaded our previous conversation.";
            addMessage(welcomeMsg, 'jarvis');
            await speak(welcomeMsg);
        } else {
            addMessage("At your service, sir. System initialized and ready. How may I help you?", 'jarvis');
            await speak("At your service, sir. System initialized and ready. How may I help you?");
        }
    }

    startOverlay.addEventListener('click', async () => {
        startOverlay.style.opacity = '0';
        
        if (!window.YT) { 
            console.log("Loading YouTube IFrame API...");
            const tag = document.createElement('script');
            tag.src = "https://www.youtube.com/iframe_api";
            const firstScriptTag = document.getElementsByTagName('script')[0];
            firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
        }

        await startFaceAuthentication(); // Calls initialization
    }, { once: true });

</script>
</body>
</html>
